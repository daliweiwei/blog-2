(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{763:function(t,v,_){t.exports=_.p+"assets/img/render-tree-construction.0c389301.png"},951:function(t,v,_){"use strict";_.r(v);var a=_(66),s=Object(a.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("ul",[a("li",[t._v("DOM 树和 CSSOM 树合并成渲染树")]),t._v(" "),a("li",[t._v("渲染树只包含渲染网页所需的节点")]),t._v(" "),a("li",[t._v("布局计算每个对象的精确位置和大小")]),t._v(" "),a("li",[t._v("绘制，使用最终渲染树将像素渲染到屏幕上")])]),t._v(" "),a("h3",{attrs:{id:"合并渲染树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#合并渲染树"}},[t._v("#")]),t._v(" 合并渲染树")]),t._v(" "),a("p",[t._v("  第一步是浏览器将 DOM 和 CSSOM 合并成一个“渲染树”，网罗网页上所有可见的 DOM 内容，以及每个节点的所有 CSSOM 样式信息。")]),t._v(" "),a("p",[a("img",{attrs:{src:_(763),alt:"render-tree-construction.png"}})]),t._v(" "),a("p",[t._v("  构建渲染树过程中，浏览器工作主要是：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("从 DOM 树的根节点开始遍历每个可见节点。")]),t._v(" "),a("ul",[a("li",[t._v("某些节点不可见（例如脚本标记、元标记），因为它们不会体现在渲染输出中，所以会被忽略。")]),t._v(" "),a("li",[t._v("某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如，在节点上设置了“display: none”属性。")])])]),t._v(" "),a("li",[a("p",[t._v("对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。")]),t._v(" "),a("p",[t._v("visibility: hidden 与 display: none 是不一样的。前者隐藏元素，但元素仍占据着布局空间（即将其渲染成一个空框），而后者 (display: none) 将元素从渲染树中完全移除，元素既不可见，也不是布局的组成部分。")])]),t._v(" "),a("li",[a("p",[t._v("发射可见节点，连同其内容和计算的样式。")])])]),t._v(" "),a("p",[t._v("  最终输出的渲染同时包含了屏幕上的所有可见内容及其样式信息。")]),t._v(" "),a("h3",{attrs:{id:"布局"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#布局"}},[t._v("#")]),t._v(" 布局")]),t._v(" "),a("p",[t._v("  有了渲染树，就可以进入“布局”阶段。开始计算各节点在设备视口内的确切位置和大小。")]),t._v(" "),a("p",[t._v("  布局流程输出一个“盒模型”，会精确地捕获每个元素在视口内的确切位置和尺寸。所有相对测量值都转换为屏幕上的绝对像素。")]),t._v(" "),a("h3",{attrs:{id:"绘制-栅格化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#绘制-栅格化"}},[t._v("#")]),t._v(" 绘制（栅格化）")]),t._v(" "),a("p",[t._v("  得到各节点的样式以及几何信息后，将渲染树中的每个节点转换成屏幕上的实际像素。")]),t._v(" "),a("p",[t._v("  “Layout”事件在时间线中捕获渲染树构建以及位置和尺寸计算。")]),t._v(" "),a("p",[t._v("  布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。")]),t._v(" "),a("h3",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("  执行渲染树构建、布局和绘制所需的时间将取决于文档大小、应用的样式，以及运行文档的设备: 文档越大，浏览器需要完成的工作就越多；样式越复杂，绘制需要的时间就越长（例如，单色的绘制开销“较小”，而阴影的计算和渲染开销则要“大得多”）。")])])}),[],!1,null,null,null);v.default=s.exports}}]);